# **Assignment 05**


1. *Using bit-band region for peripherals*
   * Convert the Blinking Led demo to use the corresponding bit-band address instead of the register address used in the peripheral region? **In Cortex M4, the peripheral alias area start from 0x42000000 to 0x43FFFFFF. By using the mapping formula, we can easy to modify direct any single bit of peripheral area without using read-modify-write process**

   * What instructions does the compiler produce in assembly for the "writing" to the GPIO bit when using bit-band address? **In normal read-modify-write process, the compiler needs to use at least 3 instructions to toggle expected bits such as LDR - load address need to change value to register; ORR - operator used to modify value (can use different operator); STR - store the value from register back to origin address. However, by using bit-banding, the compiler uses less instructions (in this example the compiler use MOV instruction to enable a single bit without reading whole register again) to modify directly a bit at origin address**
   * What were the instruction produced when writing to the GPIOx_ODR bit [5] directly? **Because the bit-band is mapped dirrectly to bit 5 of GIOPx_ODR register, so we only need to set dereference bit-band address = 1 for enable and 0 for disable**
2. Create a function with multiple arguments (5 arguments for example) and call that function from within another function. Trace thru the assembler and note:
   * How does the calling function pass the values to the called function? **In Cortex M4, R0 - R3 are also used to pass parameters and return value to and from a subroutine. Then the main function will call another function by using BL instruction. When BL called, the LK will store address of next instruction on main and PC will move to function call address. That how the program know where to get back after finish subroutine function without losing any data.**
   * What extra code did the compiler generate before calling the function with the multiple arguments? **Normally, Cortex M4 using 4 registers from R0 to R3 to passing arguments from called function to calling function. With more than 4 arguments, the compiler need to use STR - store instruction to store other arguments to Cstack, before using BL instruction to jump to calling function.**
   * What extra code did the compiler generate inside the called function with the multiple list of arguments? **In Cortex M4 when calling function with less argument, normally the return instruction address will be saved in LR registers and calling function will use BX instruction to go back to main function. However, with more arguments, the compiler also use LR register to store local variables. So, to continue tracking data flow in the main function, the compiler will PUSH R4 - R8 and LR to CStack. Finally, when the calling function done and return the result, the compiler will use POP instruction to move data from CSTACK back directly to R4 - R8 and PC to let program continue with main function.** 
*Reference by www.wikip
